# Interact
A tool for programming by interaction instead of "coding"

Imagine a "drawing" program where you "draw" by typing a series of commands, which you must submit all at once before you can see the resulting image (see [drw: a "useful tool"](https://programmingmadecomplicated.wordpress.com/2017/10/29/introducing-drw-a-useful-tool-to-solve-a-practical-problem/)). As backwards as that sounds, this is how traditional computer programming ("coding") works. This tool aims to fix that by allowing one to specify the actions of a program by *performing* them, rather than by typing textual commands. It's like "[Drawing Dynamic Visualizations](http://worrydream.com/DrawingDynamicVisualizationsTalk/)" for programming.

**Here's how it works:**

Program entities (numbers, text, lists, operations, etc.) are displayed as visual entities that can be created & modified interactively. Some operations (e.g. creating a new value, or inserting into a list) can be done by typing or drag-and-drop; and others by dragging values onto an "operation" entity, with the result of the operation (if there be any) appearing as a new entity.

All the user's actions are recorded with full undo/redo support. The user can extract steps from their past actions to create new "operation" entities. Parameters (arguments) can be added to that operation, and the steps can be edited to use those parameters. Thus, one is encouraged to experiment and explore manually, but can then "abstract" & generalize useful patterns into something repeatable (see "Create by abstracting" in [Learnable Programming](http://worrydream.com/LearnableProgramming/)).

Eventually, all the "operations" that make this tool work, will be available within the tool itself. This will allow the tool itself to be modified tool from within (and on the fly) to become whatever tool (or work in whatever way) is best for any scenario.

**Underlying Mechanics:**

(See also the [Grammar](https://github.com/d-cook/Interact/blob/master/Grammar.txt) of the description below)

All actions happen in some "context", and are stored in a list of actions for that context. Each "action" is in the list is represented as a list of values, with the first value being the operation that was performed, and the rest being the target(s) or parameter(s) of that operation. Each "value" can be a simple datum (e.g. a number), a list of "values", an object (collection of named "values"), or a may refer to the result of some other action.

When an action produces a value which is then consumed by another action, that other action does not refer directly to the value itself, but to the action that generated it. This is important for several reasons: (1) It allows changes to be made at any point in "history" without breaking continuity (e.g. you can "go back in time" and see what would have happened had a value been different). (2) Every time that an "operation" (function) is invoked, a new "context" is created just for that invocation. In other words, the *actions* are the same (shared by all), the actual values generated may differ per context.

Each "context" therefor contains the applicable set of actions, and the set of values generated by those actions.
