any    :: object | array | prim | native-function   <-- object can be a func
prim   :: string | number | bool | null
key    :: string

value  :: prim              <-- Actual prim value
          { key:value.. }   <-- Object literal of values
          [ 0, value..  ]   <-- Array literal of values
          [ 1, lookup.. ]   <-- Calculated value

lookup :: [number, idx..]  <-- Distance up the context-chain (-1 for args), Indexes down into a context
index  :: number | string  <-- Array index or Object property

func   :: { calcs:[value..], args:[string..], parent:context }

context :: { values:[any..], args:[any..   ], parent:context }  <-- Execution context

---------------------------------------------------------

EXAMPLE: (x, y, z) --> { x: x*(d/(d+z)), y: y*(d/(d+z)) }

Func: {
  parent: { values: [<*>, </>, <+>] },  <-- Lookups: [ 1,..]
  args  : ["x","y","z","d"],            <-- Lookups: [-1,..]
  calcs : [                             <-- Lookups: [ 0,..]
    [1, [1,2], [-1,3], [-1,2]],      <-- d + z
    [1, [1,1], [-1,3], [ 0,0]],      <-- d / (d+z)
    [1, [1,0], [-1,0], [ 0,1]],      <-- x * (d/(d+z))
    [1, [1,0], [-1,1], [ 0,1]],      <-- y * (d/(d+z))
    [0, {x:[1,[0,2]], y:[1,[0,3]]}]  <-- { x: x*(d/(d+z)), y: y*(d/(d+z)) }
  ]
}

ExampleCallToFunc: {
  parent: values: [Func],  <-- Lookups: [ 1,..] (Func is [1,0])
  args  : [ ],             <-- Lookups: [-1,..] (But its empty)
  calcs : [                <-- Lookups: [ 0,..]
    3,                                      <-- x = 3
    2,                                      <-- y = 2
    1,                                      <-- z = 1
    9,                                      <-- d = 9
    [1, [1,0], [0,0], [0,1], [0,2], [0,3]]  <-- Func(3,2,1,9)
  ]
}
